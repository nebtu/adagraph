#'Get a data generating function for simulating a trial
#'
#'@param corr_control correlation matrix for all the control endpoints
#'@param corr_treatment correlation matrix for all the treatment endpoints
#'@param eff vector of effect sizes (i.e. means) of the different treatment
#'  endpoints
#'@param n_cont number of data points in the control endpoints
#'@param n_treat number of data points in the treatment endpoints
#'
#'@details
#' This gives back a function, which takes as its arguments a number n and a
#' multiarm_cer_design object and returns a matrix of n * number of treatments
#' p-values. Each of those p-values is generated by drawing as many data points
#' as specified in the design object with the given correlation and mean, and
#' comparing it with a t-test to the data points generated for the controls
#' specified by treatment_assoc of the design object.
#'
#'@importFrom stats pnorm qnorm pt
#'@export
get_data_gen <- function(
  corr_control,
  corr_treatment,
  eff,
  n_cont,
  n_treat
) {
  controls <- dim(corr_control)[1]
  arms <- dim(corr_treatment)[1]

  if (length(n_cont) == 1) {
    n_cont <- rep(n_cont, controls)
  }
  if (length(n_treat) == 1) {
    n_treat <- rep(n_treat, arms)
  }

  which_arms <- ifelse(is.na(n_treat), FALSE, n_treat > 0)

  arms_used <- sum(which_arms)
  n_treat <- n_treat[which_arms]

  data_gen <- function(n, design) {
    p <- matrix(NA, nrow = n, ncol = arms)

    if (arms_used > 0) {
      treatment_assoc <- design$treatment_assoc
      control <- array(
        mvtnorm::rmvnorm(max(n_cont) * n, sigma = corr_control),
        dim = c(n, max(n_cont), controls)
      )

      treatment <- array(
        mvtnorm::rmvnorm(
          max(n_treat) * n,
          mean = eff[which_arms, drop = FALSE],
          sigma = corr_treatment[which_arms, which_arms, drop = FALSE]
        ),
        dim = c(n, max(n_treat), arms_used)
      )

      control <- aperm(control, c(2, 3, 1))
      treatment <- aperm(treatment, c(2, 3, 1))
      # now the shape is (number of treated people, number of arms, number of runs)

      #set all values outside of the desired sample size to NA
      for (i in 1:controls) {
        if (n_cont[i] < max(n_cont)) {
          control[n_cont[i]:max(n_cont), i, ] <- NA
        }
      }
      for (i in 1:arms_used) {
        if (n_treat[i] < max(n_treat)) {
          treatment[n_treat[i]:max(n_treat), i, ] <- NA
        }
      }

      cont_mean <- colMeans(control, na.rm = TRUE)
      treat_mean <- colMeans(treatment, na.rm = TRUE)
      cont_var <- matrixStats::colVars(
        control,
        na.rm = TRUE,
        dim. = c(max(n_cont), length(n_cont) * n)
      )
      dim(cont_var) <- dim(control)[-1]
      treat_var <- matrixStats::colVars(
        treatment,
        na.rm = TRUE,
        dim. = c(max(n_treat), length(n_treat) * n)
      )
      dim(treat_var) <- dim(treatment)[-1]

      p[, which_arms] <- sapply(
        seq_along(treatment_assoc[which_arms]),
        function(arm) {
          n_arm_cont <- n_cont[treatment_assoc[arm]]
          n_arm_treat <- n_treat[arm]

          t <- (treat_mean[arm, ] - cont_mean[treatment_assoc[arm], ]) /
            sqrt(
              ((treat_var[arm, ] * (n_arm_treat - 1)) +
                (cont_var[treatment_assoc[arm], ] * (n_arm_cont - 1))) /
                (n_arm_treat + n_arm_cont - 2) *
                (1 / n_arm_treat + 1 / n_arm_cont)
            )

          df <- n_arm_treat + n_arm_cont - 2

          1 - pt(t, df = df)
        }
      )
    }

    p
  }

  data_gen
}

#'@export
get_data_gen_2 <- function(
  corr_control,
  corr_treatment,
  eff
) {
  data_gen_2 <- function(n, design) {
    hyp <- design$keep_hyp
    if (any(hyp)) {
      data_gen <- get_data_gen(
        corr_control = corr_control,
        corr_treatment = corr_treatment,
        eff = eff,
        n_cont = design$n_cont_2,
        n_treat = design$n_treat_2
      )

      p2 <- data_gen(n, design)
      p <- t(apply(p2, 1, \(x) {
        1 -
          pnorm(
            sqrt(design$ad_t) *
              qnorm(1 - design$p_values_interim) +
              sqrt(1 - design$ad_t) * qnorm(1 - x)
          )
      }))
    }
    p
  }

  data_gen_2
}
